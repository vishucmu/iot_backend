//
//  Vulnerability.cpp
//  IOTRiskAssessment
//
//  Created by Siddhant Jain on 3/11/18.
//  Updated by Paul Griffioen on 6/26/18.
//  Copyright Â© 2018 Siddhant Jain. All rights reserved.
//

#include "Vulnerability.hpp"

Vulnerability::Vulnerability()
{
    //shouldn't be needing this constructor. Check what's happening here
}

Vulnerability::Vulnerability(std::string inID,std::string inName,std::string inAttackLayer,std::string inVulnerabilityCategory,double inWeight,bool inUseDeviceWeights,double inWMin,double inWMax):
m_ID(inID),
m_name(inName),
m_attackLayer(inAttackLayer),
m_vulnerabilityCategory(inVulnerabilityCategory),
m_weight(inWeight),
m_useDeviceWeights(inUseDeviceWeights),
m_wMin(inWMin),
m_wMax(inWMax)
{
    m_likelihood = 0.0;
    m_impact = 0.0;
    m_maxImpact = 0.0;
    m_numControls = 0;
    m_numDevices = 0;
    m_weight = (m_weight-m_wMin)/(m_wMax - m_wMin);
}

string Vulnerability::GetName()
{
    return m_name;
}

void Vulnerability::SetLikelihood(double inLikelihood)
{
    m_likelihood = inLikelihood;
}

void Vulnerability::SetImpact(double inImpact)
{
    m_impact = inImpact;
}

void Vulnerability::SetMaxImpact(double inMaxImpact)
{
    m_maxImpact = inMaxImpact;
}

double Vulnerability::GetLikelihood()
{
    return m_likelihood;
}

double Vulnerability::GetImpact()
{
    return m_impact;
}

void Vulnerability::AddControlWeight(double inWeight)
{
    m_numControls++;
    m_controlWeights.push_back(inWeight);
}

void Vulnerability::ClearControlWeights()
{
    m_numControls = 0;
    m_controlWeights.clear();
}

double Vulnerability::GetControlWeight()
{
    return m_numControls == 0 ? 0 : UnionLikelihood(m_controlWeights);
}

double Vulnerability::GetWeight()
{
    if(m_useDeviceWeights)
        return m_numDevices == 0 ? 0 : UnionLikelihood(m_deviceWeights);
    else
        return m_weight;
}

void Vulnerability::SetDeviceWeight(double inDeviceWeight)
{
    m_numDevices++;
    m_deviceWeights.push_back(inDeviceWeight);
}

double Vulnerability::GetInherentRisk()
{
    return m_impact*m_likelihood;
}

double Vulnerability::GetMaxInherentRisk()
{
    return m_maxImpact;
}

double Vulnerability::GetResidualRisk()
{
    double inherentRisk = GetInherentRisk();
    double controlScore = GetControlWeight();
    return inherentRisk*(1.0 - controlScore);
}

double Vulnerability::UnionLikelihood(vector<double> weights)
{
    if(weights.size() > 1)
    {
        int i;
        int j;
        vector<double> leftWeights;
        vector<double> rightWeights;
        for(i=0;i<weights.size()/2;i++)
        {
            leftWeights.push_back(weights[i]);
        }
        for(j=i;j<weights.size();j++)
        {
            rightWeights.push_back(weights[j]);
        }
        double leftUnion = UnionLikelihood(leftWeights);
        double rightUnion = UnionLikelihood(rightWeights);
        return leftUnion+rightUnion-(leftUnion*rightUnion);
    }
    else
    {
        return weights[0];
    }
}
